Chapter09
뷰와 인데스

뷰(view)
1.뷰 한개 이상의 테이블을 기반으로 생성된 가상의 테이블
2.뷰는 실제 데이터를 저장하지 않으며, 쿼리 실행 시점에 생성된 쿼리결과를 가상의 테이블로 만들어서 제공함
3. 다시말해 뷰는 물리적으로 데이터를 저장하는 것이 아니라 SELECT문을 저장한 형태로서 스토어드쿼리(Stored Queries)라고도 함
4. 뷰 실행 시에는 테이블을 조회한 것과 유사한 형태로 데이터를 확인할 수 있음


뷰생성
형식 1 : or replace view 뷰명


------------------------------------------------------------------------
/*예제9-1*/
한빛무역 데이터 베이스에서 사원 테이블을 사용하여 사원의 이름, 집전화 , 입사일, 주소를 보이는 뷰를 작성하시오 
뷰명 : view_사원
뷰을 생성할 때 컬럼명에 별명을 붙일 수 있으며, 뷰를 사용할 때에는 컬럼명에 붙인 별명을 사용해야함

CREATE OR REPLACE VIEW view_사원
AS
SELECT 이름
      ,집전화 AS 전화번호
      ,입사일
      ,주소
FROM 사원;

- 컬럼 또는 컬럼의 별명을 뷰 이름 옆에 나열할 수도 있음
CREATE OR REPLACE VIEW view_사원(이름, 전화번호, 입사일, 주소)
AS
SELECT 이름
      ,집전화 AS 전화번호
      ,입사일
      ,주소
FROM 사원;

SELECT *
FROM view_사원;

------------------------------------------------------------------------
/*예제9-2*/

제품테이블, 주문세부 테이블을 조인하여 제품명과 주문수량합을 보이는 뷰를 작성하시오 

CREATE OR REPLACE VIEW view_제품별주문수량합
AS
SELECT 제품명
      ,SUM(주문수량) AS 주문수량합
FROM 제품
INNER JOIN 주문세부
ON 제품.제품번호 = 주문세부.제품번호
GROUP BY 제품명;

SELECT *
FROM view_제품별주문수량합;
------------------------------------------------------------------------

/*예제9-3*/
'여' 사원에 대하여 사원의이름, 집전화, 입사일, 주소, 성별을 보이는 뷰를 작성하시오
뷰명 : view_사원_여


CREATE OR REPLACE VIEW view_사원_여
AS
SELECT 이름
      ,집전화 AS 전화번호
      ,입사일
      ,주소
      ,성별
FROM 사원
WHERE 성별 = '여';

SELECT *
FROM view_사원_여;


------------------------------------------------------------------------
/*예제9-4*/
예제9-3 에서 생성한 view_사원_여' 뷰로 전화번호에 '88'이 들어간 사원의 정보를 검색하시오
SELECT *
FROM view_사원_여
WHERE 전화번호 LIKE '%88%';


------------------------------------------------------------------------
/*예제9-5*/
예제 9-2에서 생성한 'view_제품별주문수량합' 뷰로 주문수량합이 1200개 이상인 레코드를 검색하시오
SELECT *
FROM view_제품별주문수량합
WHERE 주문수량합 >= 1200;

------------------------------------------------------------------------

뷰메타 정보 확인하기
형식 1 : information_schema.views 사용

/*예제9-6*/
'view_사원' 뷰의 메타 정보를 확인하시오
SELECT *
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_NAME = 'view_사원';

SHOW CREATE VIEW view_사원;

------------------------------------------------------------------------
/*예제9-7*/
view_사원 테이블 삭제
DROP VIEW view_사원;

------------------------------------------------------------------------
뷰를 통한 데이터 삽입
6가지 조건 알아보기

/*예제9-8*/
예제 9-3에서 작성한 'view_사원_여' 뷰를 사용하여 다음 레코드를 삽입하시오 . 오류가 발생한다면 이유를 생각해보시오

INSERT INTO view_사원_여(이름, 전화번호, 입사일, 주소, 성별)
VALUES('황여름','(02)587-4989','2023-02-10','서울시 강남구 청담동 23-5','여');

Error Code 1423이 발생 이유는 ?? 우리가 프라이머리 키 제약조건!


CREATE OR REPLACE VIEW view_사원_여
AS
SELECT 사원번호
      ,이름
      ,집전화 AS 전화번호
      ,입사일
      ,주소
      ,성별
FROM 사원
WHERE 성별 = '여';

ALTER VIEW view_사원_여
AS
SELECT 사원번호
      ,이름
      ,집전화 AS 전화번호
      ,입사일
      ,주소
      ,성별
FROM 사원
WHERE 성별 = '여';

INSERT INTO view_사원_여(사원번호, 이름, 전화번호, 입사일, 주소, 성별)
VALUES('E12','황여름','(02)587-4989','2023-02-10','서울시 강남구 청담동 23-5','여');

추가 후 select문을 통해 뷰에 추가되어잇는지 먼저 확인 
그래서 view_사원_여 
를 넣어줌 

SELECT *
FROM view_사원_여
WHERE 사원번호 = 'E12';

또한 뷰를 통해서 사원을 삽입했는데 여기서 사원테이블에도 들어가 있는지 확인
인설트나 업데이트같이 원래 있었던 물리적인 데이터베이스를 건들수밖에없음 
데이터베이스는 조그만한 문제가 있을경우엔 존재하지않는다 
데이터베이스는 무결점을 원칙으로 한다 .

SELECT *
FROM 사원
WHERE 사원번호 = 'E12';
------------------------------------------------------------------------

/*예제9-9*/
예제 9-2 에서 작성한 'view_제품별주문수량합' 뷰를 사용하여 레코드를 삽입하시오 . 오류가 난다면 이유를 생각해보시오

INSERT INTO view_제품별주문수량합
VALUES('단짠 새우깡', 250);

Error Code 1471
수량 group by 의 합이므로 단짠새우강의 재고수량은 250이 아닌 합계에 결과값이 나와야함

------------------------------------------------------------------------

WITH CHECK OPTION
-뷰에서 사용하는 옵션 중 하나
-특정 뷰에 대해 insert 또는 update 작업을 수행할 때 해당 작업으로 인해 뷰에서 정의한 """ 조건을 만족하지 않는 행이 생성되거나 수정되는 것을 방지함"""
-WITH CHECK OPTION 을 사용하면 뷰를 통해 데이터를 수정하거나 삽입할 때 뷰의 조건을 만족하는 데이터만 작업이 가능함
-즉, 뷰에서 사용된 조건식을 기반으로 데이터의 일관성을 보장하기 위한 제약조건
- 형식
create or replace view 뷰명
as
select문
with check option;

/*예제9-10*/
'view_사원_여'를 사용하여 '남' 사원 정보를 추가하고, 결과를 확인하시오

INSERT INTO view_사원_여(사원번호, 이름, 입사일, 주소, 성별)
VALUES('E13', '강겨울','2023-02-10','서울시 성북구 장위동 123-7','남');
이렇게 하였을 경우 정상적으로 사원 추가는 됨

SELECT *
FROM view_사원_여
WHERE 사원번호 = 'E13';
그러나 사원_여 에서는 나타나지 않음

SELECT *
FROM 사원
WHERE 사원번호 = 'E13';
사원테이블로 검색하였을 경우엔 정상적으로 나온다 .

이렇게 했을경우 사원_여 에 남사원이 들어가는게 맞는가라는 의문이 들어야함
가상뷰인 사원_여엔 없지만 기존 사원테이블에는 존재한다
그래서 아래 WITH CHECK OPTION을 추가하여 내가 원하는 view_사원_여 뷰에 남사원을 넣을 때 


CREATE OR REPLACE VIEW view_사원_여
AS
SELECT 사원번호
	  ,이름
      ,집전화 AS 전화번호
      ,입사일
      ,주소
      ,성별
FROM 사원
WHERE 성별 = '여'
WITH CHECK OPTION;

INSERT INTO view_사원_여(사원번호, 이름, 성별)
VALUES('E14', '유봄','남');

Error Code 1369가 나오게 됨 failed 가 뜸 

UPDATE view_사원_여
SET 성별 = '남'
WHERE 이름 = '황여름';
 
성별을 여에서 남으로 수정할 경우에도 안됨 (조건이 충족되지않음)
Error Code 1175


------------------------------------------------------------------------

인덱스 는 너무나 중요한 데이터베이스 관련해서 인덱스에 설명해보시오 할경우 다 나와야함

인덱스 (Index)
-데이터베이스 테이블에서 특정 컬럼이나 컬럼의집합에 대한 검색 성능을 향샹시키기 위해 사용되는 자료구조 !!
-데이터베이스의 성능 향상을 위해 중요한 역할을 수행함 (별 다섯개 무조건 외우기)

장점
1.검색속도 향상
2. 정렬 및 순서 유지
3. 중복 제거
4. 조인 성능 향상
5. 쿼리 성능 향상

기본인덱스
1. 클러스터형 인덱스 (Clustered Index)라고도 함
2. 테이블의 기본키 컬럼에 대해 행 데이터가 오름차순으로 정렬되는 인덱스
3. 기본 인덱스는 테이블당 한 개만 생성할 수 있음
4. 테이블에 대해 기본키를 정의하지 않으면 not null 제약조건과 unique 제약조건이 설정된 첫 번째 컬럼을 키로 하는 기본 인덱스가 생성됨
		설명 : 중복되지 않아야 하고 null이 많으면 검색능력 낮아짐
5. 만일 기본키 또는 적합한 unique 인덱스가 없는 경우에는 행 ID값을 키로 하는 GEN_CLUST_INDEX라는 숨겨진 기본 인덱스가 생성됨
		설명 : 프라이머리 키를 기본으로 쓰기 때문에 필요없음
6. 기본 인덱스는 사전과 유사한 방식으로 저장됨
		설명 : 기본 인덱스는 사전과 유사한 방식으로 저장됨 (이게 제일 중요함)


보조인덱스 
1. 기본인덱스 이외의 인덱스
2. 비클러스터형 인덱스 라고도함
3. 보조 인덱스는 책의 찾아보기 페이지와 유사함 (중요)
4. 보조 인덱스의 각 레코드에는 보조 인덱스에 대한 키와 기본키가 포함되며, 보조 인덱스에 있는 기본키 값으로 기본 인덱스에서 행을 검색함
5. 보조 인덱스는 한 테이블에 여러개를 생성할 수 있음


(인덱스 는 검색능력의 향상!을 위해 존재하는 것 너무나 중요함 !!
ex : 구글에서 검색어는 저장되어있는 데이터를 보여주는 것)



인덱스 생성 시 주의사항
-쿼리 패턴 분석
-테이블 크기와 메모리제한
-업데이트 비용주의
-복합 인덱스 
-중복 및 null값


기본과 보조 차이 설명해야함
SQL 전문가 시험일 땐 무조건 나옴

------------------------------------------------------------------------
B-트리 인덱스
1.가장 일반적으로 사용되는인덱스 형식으로 좌우 자식 간에 항상 균형을 이루는 균형 트리 (Balanced Tree)임
	(설명 중간값을 기준으로 찾아가는 기준으로 
	예시는 1~100까지의 숫자중 하나를 찾을 때 up down 방식으로 7번만에 찾을수 잇는 방법과 같음
	1~100만까지의 숫자도 20번이내에 찾아낼수잇음 )
2. B-트리에서 노드(Node)는 블록(BLock) 또는 페이지(Page)라고 부름
      -- 각 노드에는 인덱스키와 자식 노드의 주소인 포인터가 저장됨
3. M차 B-트리
      --최대 M개의 자식 노드를 가질 수 있는 B-트리
      --M차 B-트리에서 노드는 최대 M-1개의 키를 가질 수 있고, 노드 내부의 키들은 항상 오름차순으로 정렬된 상태를 유지함
4. 각 노드의 키들은 좌우로 다른 노드를 가리키는 포인터를 가지고 있음
      --좌측 포인터는 키보다 작은 데이터를 가진 노드를 가리키고, 우측 포인터는 키보다 큰 데이터를 가진 노드를 가리킴
5. B-트리 인덱스는 테이블 데이터를 정렬하여 B-트리 형태로 구성하며, 각 노드는 정렬된 값의 범위를 나타냄
6. 이러한 구조로 인해 효율적인 범위 검색과 정렬이 가능함

무조건 끝까지 갈 필요없이 어느정도 추려놓고 끝내야함

MySQL의 B-트리 인덱스
1.데이터는 루트 노드부터 탐색이 시작되고, 정렬된 인덱스키를 따라서 리프 노드까지 도달함
2.기본 인덱스는 리프 노드에 키가 포함된 행의 모든 데이터를 포함하므로 추가적인 데이터 조회가 필요하지 않음
3. 반면 보조 인덱스는 먼저 인덱스키와 쌍이 되는 기본키 값을 찾은 후 기본 인덱스에서 검색함


/*예제 9-11*/
날씨 테이블과 인덱스를 생성하시오
컬럼 : 년도 INT , 월 int , 일 int, 도시 varchar(20), 기온 numberic(3,1),습도 int
기본키 : 년도 + 월 + 일 + 도시
보조 인덱스 : 기온,도시

CREATE TABLE 날씨
    (
       년도 INT
      ,월 INT
      ,일 INT 
      ,도시 VARCHAR(20)
      ,기온 NUMERIC(3,1)
      ,습도 INT
      ,PRIMARY KEY(년도, 월, 일, 도시)
      ,INDEX 기온인덱스(기온)
      ,INDEX 도시인덱스(도시)
    );

여기서 기본 인덱스는 primary key 인 년도,월,일,도시에 되어있음
1차적으로 해야하는건 보조인덱스를 공부해야함
날씨 검색을 해야할 때 도시먼저 찾는다 (ex 서울 날씨 )
기온 보조인덱스 


문제 에서 10번은 %을 쓰지않음 %서울% 에서 (문제 사진있음)

인덱스 사용 시 고려 사항
1. 인덱스가 다중 컬럼으로 구성되어 있다면 옵티마이저는인덱스의 가장 왼쪽 접두사를 사용해서 컬럼을 찾게됨
      -- 만약 컬럼이 인덱스의 가장 왼쪽 접두사를 가지고 있지 않다면 인덱스를 사용할 수 없음
2.LIKE 비교에서 인수가 상수 문자열인 경우에는 인덱스를 사용할 수 있으나, %와 같은 와일드 카드 문자로 시작하는 경우에는 인덱스를 사용할 수 없음
3.인덱스의 가장 왼쪽 접두사가 반드시 모든 AND 그룹에서 사용되어야 인덱스를 사용할 수 있음

------------------------------------------------------------------------

옵티마이저의 개념
1.MySQL의 옵티마이저는 데이터베이스에서 가장 효율적인 방식으로 쿼리를 처리 할 수 있도록 SQL 쿼리의 실행 계획을 결정하는 역할을 함
2. 옵티마이저는 테이블 크기, 인덱스 품질, 통계정보, 시스템리소스 사용량 등의 다양한 정보와 통계를 기반으로 쿼리 실행 계획을 결정함


EXPLAIN
1. 쿼리의 실행 계획을 확인하기 위해 사용됨
2. 쿼리를 실행하기 전에 실행 계획을 추출하여 반환하는데, 반환된 실행 계획은 테이블 스캔, 인덱스 스캔, 조인순서, 필터링 방법 등과 같이
	어떻게 쿼리를 실행할것인지에 대한 정보를 제공함
3. EXPLAIN을 사용하여 쿼리의 실행 계획을 확인하면 비효율적인 작업을찾아내어 개선할 수 있으며, 쿼리의 성능 이슈를 파악하고 최적화 할 수 있음

/*예제 9-12*/
주문건수가 많은 고객 순으로 고객회사명별 주문건수를 보이는 쿼리의 실행 계획을 확인하시오

EXPLAIN FORMAT = TREE
SELECT 고객회사명
      ,COUNT(*) AS 주문건수
FROM 고객
INNER JOIN 주문
ON 고객.고객번호 = 주문.고객번호
GROUP BY 고객회사명
ORDER BY COUNT(*) DESC;

tree구조 - 가장 효율성이 좋음, 거의다 트리구조로 씀 
json구조 - 기계가 찾기 쉬운방식, 복잡한 작업 ( 빅데이터에 적합)

------------------------------------------------------------------------
EXPLAIN ANALYZE

/*예제 9-13*/
주문건수가 많은 고객순으로 고객회사명별로 주문건수를 보이는 쿼리에 대해 실행 계획 및 실행 결과에 대한 통계를 확인하시오

EXPLAIN ANALYZE
SELECT 고객회사명
	  ,COUNT(*) AS 주문건수
FROM 고객
INNER JOIN 주문
ON 고객.고객번호 = 주문.고객번호
GROUP BY 고객회사명
ORDER BY COUNT(*) DESC;

여기서 인덱스를 걸었다가 뺐다하면서 처리속도를 비교해보고 
데이터를 많이 넣어서 해보고 그러면서익히면 좋음






/*예제 9-11*/
CREATE TABLE 날씨
    (
       년도 INT
      ,월 INT
      ,일 INT 
      ,도시 VARCHAR(20)
      ,기온 NUMERIC(3,1)
      ,습도 INT
      ,PRIMARY KEY(년도, 월, 일, 도시)
      ,INDEX 기온인덱스(기온)
      ,INDEX 도시인덱스(도시)
    );





