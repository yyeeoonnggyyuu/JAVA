집계함수 : (Aggregate Function)  
-여러행에 걸쳐 있는 값을 묶어서 계산을 수행하여 단일 값을 반환
-레코드의 개수나 합계, 평균, 최댓값, 최솟값 등을구할 때 사용

SELECT 집계_함수
FROM 테이블명
[WHERE절];

고객 테이블에서 고객번호, 도시, 지역의 개수를 조회
SELECT COUNT(*)
	,COUNT(고객번호)
	,COUNT(도시)
            ,COUNT(지역)
FROM 고객;
고객 테이블의 마일리지 컬럼에 대하여 마일리지 합과 평균 마일리지, 최소마일리지  최대 마일리지
SELECT SUM(마일리지)
      ,AVG(마일리지)
      ,MIN(마일리지)
      ,MAX(마일리지)
FROM 고객;

-----------------------------------
도시가 서울특별시인 사람들의 합계,평균,최소,최대
SELECT SUM(마일리지)
      ,AVG(마일리지)
      ,MIN(마일리지)
      ,MAX(마일리지)
FROM 고객
WHERE 도시 = '서울특별시';
---------------------------
GROUP BY 절
고객 테이블에서 도시별 고객의 수와 해당 도시 고객들의 평균 마일리지
SELECT 도시
      ,COUNT(*) AS 고객수
      ,AVG(마일리지) AS 평균마일리지
FROM 고객
GROUP BY 도시;
GROUP BY절에 컬럼명 대신 SELECT절에 나열되어 있는 컬럼의 순번을 넣을 수 있음
SELECT 도시
      ,COUNT(*) AS 고객수
      ,AVG(마일리지) AS 평균마일리지
FROM 고객
GROUP BY 1;  SELECT에 있는 도시로 그룹을 묶어준다는 뜻 
SELECT 도시, AVG(마일리지)
FROM 고객
GROUP BY 1;

=-----------------------------------------------------------------
담장자직위별로 묶고, 같은 담당자직위에 대해서는 도시별로 묶어서 집계한 결과가(고객수와 평균 마일리지)를 보이시오
(이 때 담당자 직위 순, 도시순으로 정렬하기)
담장자직위별로 묶고, -> group by 담당자 직위
 담당자직위에 대해서는 도시별로 묶어서 -> ,도시

집계한 결과가(고객수와 평균 마일리지)를 보이시오
,COUNT(*),avg(마일리지) 
COUNT(*) AS 고객수 ,avg(마일리지) AS 평균마일리지

-----------------------------------
HAVING 절
추가조건 뒤에 붙임
EX-
고객테이블에서 도시별로 그룹을 묶어서 
select 도시
from 고객
group by 1;
고객수와 평균마일리지를 구하고 
select 도시,count(*) AS 고객수 ,avg(마일리지) AS 평균마일리지
from 고객
group by 1;
이중 고객수가 10명 이상인 레코드만 걸러내시오
select 도시,count(*) AS 고객수 ,avg(마일리지) AS 평균마일리지
from 고객
group by 1
having count(*) >=10;

이렇게 찾아가면 됨 


-------------
고객 테이블에서 도시별로 그룹을 묶고 마일리지의 합계를 구한다음 고객번호에 T로 시작하는 사람을 뽑고
마일리지의 합계가 1000이상 고객수만 뽑아줘
=
고객번호가 'T'로 시작하는 고객에 대해 도시별로 묶어서 고객의 마일리지 합을 구하시오.,
이때 마일리지 합이 1000점 이상인 레코드만 보이시오 

select 도시,고객번호, sum(마일리지)
from 고객
where 고객번호 LIKE 'T%'
group by 1,2
having sum(마일리지) >= 1000;
------------------------------------
고객테이블에서 도시로 그룹화 시켜주고 고객수와 평균마일리지를 구한 후 지역이 null인 사람만 뽑아줘 
WITH ROLLUP 
그룹별 소계와 전체 총꼐를 한번에 확인하고 싶을 때 사용
GROUP BY 절 다음에 WITH ROLLUP을 사용하면 그룹별 소계와 전체 합계를 같이 나타낼수 잇음

지역이 null인 고객에 대해 도시별로 고객수와 평균마일리지를 보이시오 , 이때 맨 마지막 행에 전체 고객수와 전체 고객에 대한 평균 마일리지도 함께 볼 수 있도록 작성하시오
000000000000000000000
여기서 지역이 null값으로 변경 안될 시 
1. Safe Update Mode 비활성화 (일시적)
Safe Update Mode를 일시적으로 비활성화하여 문제를 해결할 수 있습니다. 다음 명령어를 실행하여 현재 세션에서 Safe Update Mode를 비활성화할 수 있습니다:
SET SQL_SAFE_UPDATES = 0;
--
UPDATE 고객
SET 지역 = NULL
WHERE 지역 = '';
--
SET SQL_SAFE_UPDATES = 1;
00000000000000000000000000

위의 예제를 SELECT절에 IFNULL() 을 추가하여 보완한 SQL문
도시에 null이 있을 시 총계로 채워줘
SELECT IFNULL(도시,'총계') AS 도시
      ,COUNT(*) AS 고객수
      ,AVG(마일리지) AS 평균마일리지
FROM 고객
WHERE 지역 IS NULL
GROUP BY 도시
WITH ROLLUP;

-------------------------------------------------------------

담장자 직위에 '마케팅'이 들어가 있는 고객에 대해 고객 (담당자직위,도시) 별 고객수를 보이시오 . 
담당자직위별 고객수와 전체 고객수도 함께 볼 수 있도록 조회
select 담당자직위,도시,count(*) as 고객수
from 고객
where 담당자직위 like '%마케팅%'
group by 1,2
with rollup;
--------------------------------
이거 다시해야함 !!!!! 이해 안됨
GROUPING() 
- WITH ROLLUP의 결과로 나온 NULL에 대해서는 1을반환, 그렇지않으면 NULL에 대해서는 0

담장자 직위가 '대표이사'인 고객에 대하여 지역별로 묶어서 고객수를 보이고, 전체 고객수도 함께 보이시오
select 지역, count(*) as 고객수
,grouping(지역) as 구분
from 고객
where 담당자직위 = '대표 이사'
group by 1
with rollup;

다른 방법은 
select 
case 
when grouping(지역) = 1 then '총계'
else 지역
end as 지역,
count(*) as 고객수
from 고객
where 담당자직위 = '대표 이사'
group by 지역 with rollup;

case 문을 이용하여 한 방법도 있음 이걸 공부해보기!!
-----------------------------

GROUP_CONCAT() - 각 행에 있는 값을 결합함

GROUP_CONCAT()을 사용하여 사원 테이블에 들어있는 이름을 한 행에 나열하시오
select GROUP_CONCAT(이름)
FROM 사원;

고객 테이블에 들어있는 지역을 한행에 나열하되 중복되는지역은 한번씩만 보이시오
select GROUP_CONCAT(DISTINCT 지역)
FROM 고객;

-----------------------------------------------------
고객 테이블에서 도시별로 고객회사명을 나열
select 도시,group_concat(고객회사명) AS 고객회사명목록
from 고객
group by 도시;

-------------------------------------

