join subqurey 알아보기

데이터 조작어

-1. DML의 개요
데이터 조작어 (Data Manipulation Langyage, DML)
데이터를 관리하는데 사용하는 언어
예제 7-1부터
--INSERT 
	테이블에 새로운 행을 삽입하는 경우에 사용함
	삽입할 컬럼명이 생략된 경우 삽입할 값이 테이블의 컬럼수와 같아야하며, 순서도 동일해아함
	형식	
	 INSERT INTO 테이블명
	VALUES(값1, 값2, ....);	
	
	7-1 
	INSERT INTO 부서
	VALUES('A5', '마케팅부');	

	7-2 

INSERT INTO 제품
VALUES(91, '연어피클소스',NULL, 5000, 40);
	제품번호, 제품명, 단가. 재고

7-4
INSERT INTO 사원(사원번호, 이름, 직위, 성별, 입사일)
VALUES('E20', '김사과','수습사원', '남', CURDATE())
	 ,('E21', '박바나나','수습사원', '여', CURDATE())
     ,('E22', '정오렌지','수습사원', '여', CURDATE());
이렇게 INSERT INTO 사원 () 괄호안에 컬럼명을 다 넣어주어야함.

여기서 into가 아니라 ignore을 하면 에러는 무시하고 넘어감

--UPDATE 
	기존행에 잇는 데이터 갑을 변경할 때 사용
	update 문에 where절이 ㅇ없으면 모든행의 값이 변경되므로 주의
형식
UPDATE 테이블명
SET 컬럼 1 = 값1
    , 컬럼 2 = 값2
[where 조건];

만약 업데이문을 실행햇을 때 오류가 발생한다면 
2장 61p의 (하나더 알기 참고)
edit -> preferences -> SQL Editor -> 맨 밑의 safe upatates 알아보기
update 사원
set 이름 = '김레몬'
where 사원번호 = 'e20';
여기서 where를 안쓰면 이름컬럼의 모든 데이터이름이 김레몬으로 바뀜 그 순간 모든 데이터는 망가지니 주의!
예제 7-6
UPDATE 제품
SET 포장단위 = '200 ml bottles'
WHERE 제품번호 = 91;
여기서도 WHERE를 안 쓸 경우 포장단위가 다 바뀜 주의 필요

제품번호가 91인 제품에 대하여 단가를 10% 인상하고, 재고에서 10을 뺀 값으로 변경
UPDATE 제품
SET 단가 = 단가 * 1.1
   ,재고 = 재고 - 10
WHERE 제품번호 = 91;
이렇게 수정 가능

UPDATE 와 DELETE 사용시엔 WHERE를 꼭 사용하고 언제든 몇번은 더 생각해서 사용하기 


-DELETE
	기존에 있는 행을 삭제할 때 사용함	
	만약 DELETE 문에 WHERE절이 없으면 모든행이 삭제되므로 주의
DELETE FROM 테이블명
[WHERE 조건];

delete from 제품
where 제품번호 = 91;
사원테이블에서 입사일이 가장 늦은 사원 3명의 레코드를 삭제하시오
delete from 사원
order by 입사일 desc
limit 3;

select *
from 사원
where 이름 in('김레몬', '박바나나', '정오렌지');
김레몬, 박바나나, 정오렌지 가 있냐라는 문구 


	
-INSERT ON DUPLICATE KEY UPDATE
	레코드가 없다면 새롭게 추가하고, 이미 있다면 데이터를 변경하는 경우에 사용
형식
INSERT INTO 테이블명(컬럼1, 컬럼2, 컬럼3,...)
VALUES (값1, 값2, 값3, ...)
ON DUPLICATE KEY UPDATE 
컬럼2 = 값2, 컬럼3 = 값3, ...;

ON DUPLICATE KEY UPDATE를 사용하려면 기본키 지정이 필요함
 여기선 INSERT INTO 테이블명 

91번 제품이 없다면 레코드를 추가하고, 이미 존재한다면 값을 변경하시오
INSERT INTO 제품(제품번호, 제품명, 단가, 재고)
VALUES(91, '연어피클핫소스', 6000, 50)
ON DUPLICATE KEY UPDATE 제품명 = '연어피클핫소스', 단가 = 6000, 재고 = 50;



-2. DML 심화
-INSERT INTO SELECT
	SELET문의 결과를 다른테이블에 삽입하려면 INSERT문에서 VALUES 대신 SELECT 문장을 넣음
	이때 SELECT문의 컬럼수와 INSERT문에 있는 컬럼 수는 동일해야하고 , 순서도 같아야함

7-11 고객 주문요 약 테이블을 만들고, 레코드를 추가하시오
컬럼명       	- 자료형
고객번호(기본키)    -CHAR(5)
고객회사명	-VARCHAR(50)
주문건수		-INT
최종주문일	-DATE

CREATE TABLE 고객주문요약
(
    고객번호 CHAR(5) PRIMARY KEY,
    고객회사명 VARCHAR(50),
    주문건수 INT,
    최종주문일 DATE
);
	
7-11
고객주문 요약 테이블을 만들고, 레코드를 추가하시오
	
-UPDATE SELECT
	UPDATE문에서 서브쿼리를 사용할 수도 있음
	변경할 값을 얻기 위해서는 set 절에서 select문을 사용함
	서브쿼리의 select문에는 반드시 별명을 붙여야 하고, 서브쿼리의 결과는 단일값이어야함

제품번호가 91인 제품의 단가를 '소스' 제품들의 평균단가로 변경
예제 7-12
update 제품
set 단가 = (
			select*
            from (
					select avg(단가)
                    from 제품
                    where 제품명 like '%소스%'
                    ) as t
          )
 where 제품번호 = 91;

여기서 이부분이 단가를 평균을구해서 단일값으로 변경해줘
             (
	select*
            from (
	select avg(단가)
                    from 제품
                    where 제품명 like '%소스%'
                    ) as t
          )        

/*예제7-13*/ -- 실행이 안되네 그전에 하지않은 작업이 있는 듯 확인해보기
한번이라도 주문한 적이 있는 고객의 마일리지를 10%인상하시오
UPDATE 고객
      ,(
        SELECT DISTINCT 고객번호
        FROM 주문
       ) AS 주문고객
SET 마일리지 = 마일리지 * 1.1
WHERE 고객.고객번호 IN (주문고객.고객번호);

DISTINCT 겹칠경우 한번만 쓴다

여기서 실행이 안된다면 lock가 걸려잇음 
SET SQL_SAFE_UPDATES = 0;
으로 안전모드 비활성화해주고 추후에 
SET SQL_SAFE_UPDATES = 1;
해서 안전모드 재실행

결과를 확인하기 위한 select문 ( 뜻은 주문테이블에 한번이라도 주문한 고객만 보여줘)

select *
from 고객
where 고객번호 in (select distinct 고객번호 
		from 주문
		);
이렇게 확인하는 이유는 
주문테이블에서 고객번호만 있는 놈들만 뽑으면 마일리지 1.1배 한것을 볼 수 잇음

-UPDATE JOIN
	INNER JOIN 을 사용하여 다른 테이블의 행과 일치하는 행을 수정할 수 잇음
	LEFT OUTER JOIN 을 사용하여 그렇지 ㅇ낳은 행을 수정할 수도 있음
	변경할 값에는 상수나 수식뿐만 아니라 조인할 테이블에 있는 컬럼에 기반하여 값을 넣을 수도 있음

ANSI SQL 표현

Non-ANSI SQL 표현

/*예제7-14*/
마일리지 등급이 's'인 고객의 마일맂에 1000점씩 추가하시오

/*ANSI SQL*/
UPDATE 고객
INNER JOIN 마일리지등급
ON 마일리지 BETWEEN 하한마일리지 AND 상한마일리지
SET 마일리지 = 마일리지 + 1000
WHERE 등급명 = 'S';

고객테이블의 마일리지 등급을 조인해서 등급이 s인 놈들만
/*Non-ANSI SQL*/
UPDATE 고객
      ,마일리지등급
SET 마일리지 = 마일리지 + 1000
WHERE 마일리지 BETWEEN 하한마일리지 AND 상한마일리지
AND 등급명 = 'S';

결과값 확인  select문
select 고객번호,고객회사명,마일리지
from 고객
INNER JOIN 마일리지등급
ON 마일리지 BETWEEN 하한마일리지 AND 상한마일리지
where 등급명 = 's';


-DELETE SELECT
	DELETE문에서도 삭제할 레코드를 찾기 위하여 서브쿼리를 사용할 수 있음

/*예제7-15*/

주문테이블에는 존재하나 주문세부 테이블에는 존재하지 않는 주문번호를 주문테이블에서 삭제하시오
DELETE FROM 주문
WHERE 주문번호 NOT IN (
                     SELECT DISTINCT 주문번호
                     FROM 주문세부
                    );

없는 녀석들만 뽑아내기 NOT IN


Collation 에러가 발생하는 경우 
조인을 ㅎ사거나 IF, CASE 등으로 값을 비교할 때 양쪽 테이블의 Collation이 다를때 다음과 같은 오류가 발생할 수 있음
Error Code : 1267.
ALTER TABLE 고객 CONVERT TO CHAR SET utf8mb4 COLLATE utf8mb4_general_ci;
ALTER TABLE 주문 CONVERT TO CHAR SET utf8mb4 COLLATE utf8mb4_general_ci;
ALTER TABLE 주문세부 CONVERT TO CHAR SET utf8mb4 COLLATE utf8mb4_general_ci;
ALTER TABLE 제품 CONVERT TO CHAR SET utf8mb4 COLLATE utf8mb4_general_ci;



-DELETE JOIN
	INNER JOIN을 사용하여 두 테이블에서 일치하는 행을 모두 삭제할 수 있음
	LEFT OUTER JOIN을 사용하여 일치하지 않는 행읋 삭제할 수도 있음
ANSI SQL 표현

예제 7-16
주문번호 'H0248'에 대한 내역을 주문 테이블과 주문세부 테이블에서 모두 삭제하시오. 하나의 문장으로 작업해보기
-주문 테이블, 주문세부 테이블에 주문번호 'H0248'이 존재하는지 확인하기
조인을 이요하여

/*ANSI SQL*/
DELETE 주문
      ,주문세부
FROM 주문
INNER JOIN 주문세부
ON 주문.주문번호 = 주문세부.주문번호
WHERE 주문.주문번호 = 'H0248';

/*Non-ANSI SQL*/
DELETE 주문
      ,주문세부
FROM 주문
    ,주문세부
WHERE 주문.주문번호 = 주문세부.주문번호
AND 주문.주문번호 = 'H0248';	


예제 7-17 
한번도 주문한 적이 없는 고객의 정보를 삭제하시오
-한번도 주문한적이 없는 고객검색하기

SELECT 고객.*
FROM 고객
LEFT OUTER JOIN 주문  ( 주문테이블에 있는 null값을 포함하라 )
ON 고객.고객번호 = 주문.고객번호
WHERE 주문.고객번호 IS NULL;

























